# Stack:-
# Stack works on the principle of LIFO(Last In First Out) means last inserted element will e removed first.
# we can perform various operations on stack:-
# 1. push() - insert element in stack
# 2. pop() - remove element from stack
# 3. display() - display element of stack

# Push:-using push operation we can insert the element into the stack.
# Pop:- using pop operation we can  retrieve or remove or delete the element from the stack.
# Stack can be implemented in 3 ways:-
# 1. using list
# 2. using linkedlist
# 3. using dequeue class.

# Queue:- 
# Queue works on the principle of FIFO(First In First Out) means first inserted element will be removed first.
# we can perform various operations on queue:-
# 1. enqueue() - insert element in queue
# 2. dequeue() - remove element from queue
# queue can be implememnted in 3 ways:-
# 1. using list
# 2. using linkedlist
# 3. using dequeue class.

# Implementation of stack using list:-
s=[]
size=int(input("Enter the size of stack:"))
top=-1
while(True):
    print("1. Push, 2. Pop, 3. Display, 4. Exit")
    opt=int(input("Enter your option:"))
    if(opt==1):
        if(top<size-1):
           top=top+1
           ele=int(input("Enter the element:"))
           s.append(ele)
        else:
            print("Stack is full")
    elif(opt==2):
        if(top==-1):
            print("Stack is empty")
        else:
            print("Deleted element is:",s.pop())
            top=top-1
    elif(opt==3):
        print(s)
    elif(opt==4):
        break

#Implementation of Stack using Linkedlist:-
class Node:
    def __init__(self,data):
        self.data=data
        self.next=None
class Stack:
    def __init__(self):
        self.head=None
    def isempty(self):
        if(self.head==None):
            return True
        else:
            return False
    def push(self,data):
        if(self.head==None):
            self.head=Node(data)
        else:
            temp=self.head
            ne=Node(data)
            ne.next=temp
            self.head=ne
    def pop(self):
        if(self.isempty()==True):
            print("Stack is empty")
        else:
            temp=self.head
            self.head=temp.next
            temp.next=None
            print("Deleted element is:",temp.data)       
    def display(self):
        temp=self.head
        if(self.head is None):
            print("Stack is empty")
        else:
            while(temp):
                print(temp.data,end=" ")
                temp=temp.next       
            
s1=Stack()
s1.push(10)
s1.push(20)
s1.push(30)
s1.push(40)
s1.pop()
s1.display()
print()
s1.pop()
s1.display()

#Implementation of Stack using deque:-
from collections import deque
s=deque()
s.append("Dainik")
s.append("3+4j")
s.append(3.5)
s.append(4)
print(s)
s.pop()
print(s)
s.pop()
print(s)
s.pop()
s.pop()
print(s)

#Implementation of Queue using Deque:-
from collections import deque
s=deque()
s.append("Dainik")
s.append("3+4j")
s.append(3.5)
s.append(4)
print(s)
s.popleft()
print(s)
s.popleft()
print(s)
s.popleft()
s.popleft()
print(s)

#Implementation of Queue using List:-
q=[]
size=int(input("Enter the size of Queue:"))
top=-1
while(True):
    print("1. Push, 2. Pop, 3. Display, 4. Exit")
    opt=int(input("Enter your option:"))
    if(opt==1):
        if(top<size-1):
           top=top+1
           ele=int(input("Enter the element:"))
           q.append(ele)
        else:
            print("Queue is full")
    elif(opt==2):
        if(top==-1):
            print("Queue is empty")
        else:
            print("Deleted element is:",q.pop(0))
            top=top-1
    elif(opt==3):
        print(q)
    elif(opt==4):
        break

#Implementation of Queue using LinkedList:-
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self, max_size):
        self.head = None
        self.max_size = max_size
        self.size = 0

    def isempty(self):
        return self.head is None

    def isfull(self):
        return self.size == self.max_size

    def enqueue(self, data):
        if self.isfull():
            print("Queue is full")
            return
        
        if self.head is None:
            self.head = Node(data)
        else:
            temp = self.head
            while temp.next:
                temp = temp.next
            temp.next = Node(data)
        self.size += 1

    def dequeue(self):
        if self.isempty():
            print("Queue is empty")
        else:
            temp = self.head
            self.head = temp.next
            temp.next = None
            self.size -= 1
            print("Deleted element is:", temp.data)

    def display(self):
        temp = self.head
        if self.head is None:
            print("Queue is empty")
        else:
            while temp:
                print(temp.data, end=" ")
                temp = temp.next

q1 = Queue(4)
q1.enqueue(10)
q1.enqueue(20)
q1.enqueue(30)
q1.enqueue(40)
q1.enqueue(50)
q1.display()
q1.dequeue()
q1.display()
q1.dequeue()
q1.display()


# Priority Queue:-
# -> Priority Queue is similar to queue operation. 
# -> In priority queue we can assign the priority according to the priority elements gets deleted.
# -> Different ways of priority queue:-

# 1) Ascending order
# 2) DescendingÂ order

class pq:
  def init(self):
    self.queue=[]
  def push(self,x):
    self.queue.append(x)
  def display(self):
    print(self.queue)
  def delete(self):
    self.queue.sort() #[1,2,5,7,8]
    print("Deleted element is:", self.queue.pop(0))

p1=pq()
p1.push(7)
p1.push(2)
p1.push(1)
p1.push(8)
p1.push(5)
p1.display()
p1.delete()
p1.delete()
p1.display()
